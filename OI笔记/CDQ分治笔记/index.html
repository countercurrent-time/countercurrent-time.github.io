<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"countercurrent-time.gitee.io","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="前置知识：归并排序。 CDQ 分治是一种基于时间的离线分治算法。由于思想较简单，限制较少，效率较高，所以 CDQ 分治被广泛应用在各种场合。其中以多维偏序问题最为经典。">
<meta property="og:type" content="article">
<meta property="og:title" content="CDQ分治笔记">
<meta property="og:url" content="https://countercurrent-time.gitee.io/OI%E7%AC%94%E8%AE%B0/CDQ%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name">
<meta property="og:description" content="前置知识：归并排序。 CDQ 分治是一种基于时间的离线分治算法。由于思想较简单，限制较少，效率较高，所以 CDQ 分治被广泛应用在各种场合。其中以多维偏序问题最为经典。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-29T13:26:45.000Z">
<meta property="article:modified_time" content="2020-10-01T11:05:34.691Z">
<meta property="article:author" content="逆流之时">
<meta property="article:tag" content="离线算法">
<meta property="article:tag" content="CDQ分治">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://countercurrent-time.gitee.io/OI%E7%AC%94%E8%AE%B0/CDQ%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CDQ分治笔记 | </title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title"></h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#P3374-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-1"><span class="nav-number">1.</span> <span class="nav-text">P3374 【模板】树状数组 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CF1042D-Petya-and-Array"><span class="nav-number">2.</span> <span class="nav-text">CF1042D Petya and Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P1858-%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">P1858 多人背包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P3810-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%EF%BC%88%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">P3810 【模板】三维偏序（陌上花开）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P3157-CQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">5.</span> <span class="nav-text">P3157 [CQOI2011]动态逆序对</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P4169-Violet-%E5%A4%A9%E4%BD%BF%E7%8E%A9%E5%81%B6-SJY%E6%91%86%E6%A3%8B%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">P4169 [Violet]天使玩偶&#x2F;SJY摆棋子</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a href = "/" class="site-author-name" itemprop="name">逆流之时</a>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="/404/" title="&#x2F;404&#x2F;">导航</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://countercurrent-time.gitee.io/OI%E7%AC%94%E8%AE%B0/CDQ%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="逆流之时">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CDQ分治笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-29 21:26:45" itemprop="dateCreated datePublished" datetime="2020-02-29T21:26:45+08:00">2020-02-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-01 19:05:34" itemprop="dateModified" datetime="2020-10-01T19:05:34+08:00">2020-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/OI%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">OI笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>前置知识：归并排序。</p>
<p>CDQ 分治是一种基于时间的离线分治算法。由于思想较简单，限制较少，效率较高，所以 CDQ 分治被广泛应用在各种场合。其中以多维偏序问题最为经典。</p>
<a id="more"></a>

<p>设 $cdq(l, r)$ 为对于 $\forall k \in [l, r)$ 所有的查询操作，如果改变修改操作的先后顺序不会对询问结果造成影响，则可以使用 CDQ 分治计算 $1 \sim k - 1$ 中修改操作的贡献。CDQ 分治的框架如下：</p>
<ol>
<li>设 $mid = (l + r) / 2$；</li>
<li>递归计算 $cdq(l, mid)$ 与 $cdq(mid, r)$；</li>
<li>计算区间 $[l, mid)$ 中的修改操作对 $[mid, r)$ 中的查询操作的贡献。</li>
</ol>
<p>CDQ 分治的框架正是分治的“分而治之”思想体现，所以写起来非常自然。</p>
<p>例题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1042D">CF1042D Petya and Array</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1858">P1858 多人背包</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3157">P3157 [CQOI2011]动态逆序对</a></li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4169">P4169 [Violet]天使玩偶/SJY摆棋子</a></li>
</ul>
<h1 id="P3374-【模板】树状数组-1"><a href="#P3374-【模板】树状数组-1" class="headerlink" title="P3374 【模板】树状数组 1"></a>P3374 【模板】树状数组 1</h1><p>从 CDQ 分治的基于时间分治的思想出发，由于计算 $cdq(l, r)$ 之前先递归计算 $cdq(l, mid)$ 与 $cdq(mid, r)$，所以我们计算 $cdq(l, mid)$ 与 $cdq(mid, r)$ 时可以按需求对其中的操作重新排序，且递归计算之后对于 $\forall i \in cdq[l, mid), \forall j in [mid, r)$ 中的第 $i, j$ 项操作，仍有第 $i$ 项操作的时间在第 $j$ 项操作之前。</p>
<p>我们将查询区间 $[l, r]$ 之和的操作分为两个操作：分别查询 $[1, r]$ 之间的和与 $[1, l - 1]$ 之间的和（在代码中用 $op = 3$ 与 $op = 2$ 表示以加以区分），则两者之差就是答案。于是我们可以发现以下性质：对位置 $x$ 的修改操作与对区间 $[1, y]$ 的查询操作，查询操作 $[1, y]$ 需要计算修改操作 $x$ 的贡献，当且仅当满足以下条件：</p>
<ol>
<li>$x \le y$，即对位置 $x$ 的单点修改在区间 $[1, y]$ 范围内；</li>
<li>对位置 $x$ 修改的时间在查询区间 $[1, y]$ 的操作之前。</li>
</ol>
<p>由于 CDQ 分治的第 3 条步骤，我们只考虑区间 $[l, mid)$ 中的修改操作对 $[mid, r)$ 中的查询操作的贡献，而对于区间 $[l, mid)$ 中的修改与 $[mid, r)$ 中的查询，条件 1 总是满足，所以我们需要设法以最简单的方式使条件 2 总是满足。</p>
<p>于是我们考虑模仿归并排序的方法：</p>
<p>将操作存入结构体，结构体中的成员 $id$ 存储以下数据：对于修改操作，$id$ 存储单点修改的位置；对于查询操作，$id$ 存储查询的右端点（左端点总是 1）。</p>
<p>在 $cdq(l, r)$ 的计算过程中，我们试图将 $[l, r)$ 之间的操作重新按 $id$ 排序，并且假设我们已经在 $cdq(l, mid)$ 与 $cdq(mid, r)$ 的计算过程中使 $[l, mid)$ 与 $[mid, r)$ 之间的操作已经分别按 $id$ 排序。我们用两个指针分别扫描 $[l, mid)$ 与 $[mid, r)$，按归并排序的方式使两个 $id$ 有序的序列合并为一个序列，并在这个过程中，由于 $id$ 从小到大，所以条件 2 也总是满足。</p>
<p>此处单独计算 $cdq(l, r)$ （不考虑递归计算）的时间复杂度为 $O(n)$，可以以类似归并排序的分析方法得出 $cdq(l, r)$ （考虑递归计算）的时间复杂度为 $O(n \log n)$。</p>
<p>实际测试中 CDQ 分治的常数为树状数组的三倍左右。</p>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oper</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, id, val;</span><br><span class="line">&#125;a[N * <span class="number">3</span>], tmp[N * <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> q_cnt, ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l + <span class="number">1</span> == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, sum = <span class="number">0</span>;</span><br><span class="line">    cdq(l, mid), cdq(mid, r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l, j = l, k = mid; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= r || (j &lt; mid &amp;&amp; a[j].id &lt;= a[k].id)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].op == <span class="number">1</span>) sum += a[j].val;</span><br><span class="line">            tmp[i] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k].op == <span class="number">2</span>) ans[a[k].val] -= sum;</span><br><span class="line">            <span class="keyword">if</span>(a[k].op == <span class="number">3</span>) ans[a[k].val] += sum;</span><br><span class="line">            tmp[i] = a[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a + l, tmp + l, (r - l) * <span class="keyword">sizeof</span>(oper));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        a[cnt++] = oper&#123;<span class="number">1</span>, i, x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) a[cnt++] = oper&#123;<span class="number">1</span>, x, y&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[cnt++] = oper&#123;<span class="number">2</span>, x - <span class="number">1</span>, q_cnt&#125;;</span><br><span class="line">            a[cnt++] = oper&#123;<span class="number">3</span>, y, q_cnt++&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cdq(<span class="number">0</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q_cnt; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

<h1 id="CF1042D-Petya-and-Array"><a href="#CF1042D-Petya-and-Array" class="headerlink" title="CF1042D Petya and Array"></a>CF1042D Petya and Array</h1><p>题意：对于序列 $a[1 \cdots n]$，计算有多少子区间满足子区间之和小于 $t$。</p>
<p>看到本题，想到前缀和优化，于是我们先对序列的所有数进行前缀和处理。然后考虑对于每一个 $r \in [1, n]$，计算以 $r$ 为区间右端点的符合题意的区间数量。我们想到用树状数组计算，但本题值域较大，使用树状数组需要离散化，所以我们考虑使用 CDQ 分治。</p>
<p>具体来说，我们对于序列 $[l, r)$，将其分为 $[l, mid)$ 与 $[mid, r)$ 两段，将每一段递归计算。合并时将对于 $[l, mid)$ 的每个数 $a_i$，通过尺取法计算 $[mid, r)$ 中有多少数 $a_j$ 满足 $a_j - a_i &lt; t$，然后将两段有序数组归并。</p>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, l, r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">200005</span>], t, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    merge(l, mid), merge(mid, r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = mid; i &lt; mid; i++, ans += j - mid)</span><br><span class="line">        <span class="keyword">while</span> (j &lt; r &amp;&amp; a[j] - a[i] &lt; t) j++;</span><br><span class="line">    <span class="built_in">std</span>::inplace_merge(a + l, a + mid, a + r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]), a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    merge(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

<h1 id="P1858-多人背包"><a href="#P1858-多人背包" class="headerlink" title="P1858 多人背包"></a>P1858 多人背包</h1><p>本题看上去和 CDQ 分治没有什么关系，却用上了归并排序的思想。</p>
<p>首先，我们考虑从普通背包的状态扩展到本题的状态：使用 <code>f[i][j]</code> 表示体积为 $i$ 时的第 $j$ 优解。那么我们就要考虑怎么从 <code>f[i - w[a]][]</code> 扩展到 <code>f[i][]</code>。</p>
<p>我们知道，从 <code>f[i - w[a]][j]</code> 不一定会扩展到 <code>f[i][j]</code>，但可以确定的是 <code>f[i - w[a]][j]</code> 有可能可以扩展到 <code>f[i][]</code> 的其他位置。看上去这些状态之间没有什么必然联系，不过我们可以考虑的是怎么从新分配新的 <code>f[i - w[a]][] + v[a]</code> 和已经推出来的 <code>f[i][]</code>，即从 $f_{i, j} (j \in [1, k])$ 和 $f_{i - w_a, j} (j \in [1, k]) + v_a$ 这 $2k$ 个元素中中选出 $k$ 个最大值。我们可以很容易想到 <code>f[i][j]</code> 随着 <code>j</code> 的增长单调递增，所以我们采用归并排序实现两个数组的合并和选取前 $k$ 大值。</p>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">5005</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">205</span>], v[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmp[<span class="number">55</span>] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, p = <span class="number">1</span>; p &lt;= k; )</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; b[j] + v) tmp[p++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[p++] = b[j++] + v;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= w; i--) upd(f[i], f[i - w], v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) ans += f[m][i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

<h1 id="P3810-【模板】三维偏序（陌上花开）"><a href="#P3810-【模板】三维偏序（陌上花开）" class="headerlink" title="P3810 【模板】三维偏序（陌上花开）"></a>P3810 【模板】三维偏序（陌上花开）</h1><p>对于二维偏序（如求逆序对），我们可以用归并排序解决，因为归并排序实际就是 CDQ 分治的简化版。</p>
<p>而对于三维偏序，我们可以对第一维直接排序，第二维使用 CDQ 分治处理，然后第三维使用数据结构统计，也可以再次使用 CDQ 分治统计。</p>
<p>具体来说，为了维护单点修改与前缀和，我们使用树状数组，对于 $[l, mid)$ 内的元素，执行 <code>add(a[i].c, a[i].cnt)</code> 更新；对于 $[mid, r)$ 内的元素，执行 <code>sum(a[i].c)</code> 累加答案。</p>
<p>不过要注意以下细节：</p>
<ol>
<li>注意排序关键字不能只有第一维，否则去重时相同的花可能不会排到一起。</li>
<li>排序后要对每一朵花去重，否则对相同的花统计答案时会远不如去重方便。</li>
<li>合并完后要将树状数组清零，但不可以用 <code>memset()</code> ，否则时间复杂度会变成 $O(n^2)$。</li>
</ol>
<p>另外，对于多维偏序，我们可以得到通用的解法：</p>
<ol>
<li>使用排序、树状数组、CDQ分治、平衡树等数据结构与算法不断将 $n$ 维偏序问题降维为 $n - 1$ 维偏序问题，直到 $n = 1$，时间复杂度为 $O(n \log ^ {k - 1} n)$；</li>
<li>使用 bitset 配合分块（时间复杂度 $O(k \frac{n ^ 2}{\omega})$）或者 KD Tree（时间复杂度 $O(kn ^ \frac{2k - 3}{k - 1})$）直接解决多维偏序问题。</li>
</ol>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oper</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, cnt = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> oper&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != x.a) <span class="keyword">return</span> a &lt; x.a;</span><br><span class="line">        <span class="keyword">if</span> (b != x.b) <span class="keyword">return</span> b &lt; x.b;</span><br><span class="line">        <span class="keyword">return</span> c &lt; x.c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> oper&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == x.a &amp;&amp; b == x.b &amp;&amp; c == x.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= k; x += lowbit(x)) c[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= lowbit(x)) tot += c[x];</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l + <span class="number">1</span> == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    cdq(l, mid), cdq(mid, r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l, j = l, k = mid; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= r || (j &lt; mid &amp;&amp; a[j].b &lt;= a[k].b)) &#123;</span><br><span class="line">            add(a[j].c, a[j].cnt);</span><br><span class="line">            tmp[i] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k].ans += sum(a[k].c);</span><br><span class="line">            tmp[i] = a[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; mid; i++) add(a[i].c, -a[i].cnt);</span><br><span class="line">    <span class="built_in">memcpy</span>(a + l, tmp + l, (r - l) * <span class="keyword">sizeof</span>(oper));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].a, &amp;a[i].b, &amp;a[i].c);</span><br><span class="line">    <span class="built_in">std</span>::sort(a, a + n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp;&amp; a[i] == tmp[cnt - <span class="number">1</span>]) tmp[cnt - <span class="number">1</span>].cnt++;</span><br><span class="line">        <span class="keyword">else</span> tmp[cnt++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, tmp, cnt * <span class="keyword">sizeof</span>(oper));</span><br><span class="line">    cdq(<span class="number">0</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) ans[a[i].ans + a[i].cnt] += a[i].cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

<h1 id="P3157-CQOI2011-动态逆序对"><a href="#P3157-CQOI2011-动态逆序对" class="headerlink" title="P3157 [CQOI2011]动态逆序对"></a>P3157 [CQOI2011]动态逆序对</h1><p>由于插入比删除容易，所以我们倒序处理，把正序删除装换成倒序插入，则问题转化为将不断插入 $n$ 个元素，同时统计这个元素插入这个元素新增的逆序对数量。</p>
<p>每个元素有三个维度：时间、位置和大小，考虑 CDQ 分治。</p>
<p>插入一个元素的新增逆序对总数为：位置比它小，权值比它大和位置比它大，权值比它小的元素个数之和。</p>
<p>所以我们分两次：正序循环和倒序循环，分别处理上面的第一、二种元素，同时要在正序循环时将元素按位置排序。</p>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">oper</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">-1</span>, id, val;</span><br><span class="line">&#125;a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= n; x += lowbit(x)) c[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= lowbit(x)) tot += c[x];</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l + <span class="number">1</span> == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    cdq(l, mid), cdq(mid, r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l, j = l, k = mid; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= r || (j &lt; mid &amp;&amp; a[j].id &lt; a[k].id)) &#123;</span><br><span class="line">            add(a[j].val, <span class="number">1</span>);</span><br><span class="line">            tmp[i] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[a[k].time] += j - l - sum(a[k].val);</span><br><span class="line">            tmp[i] = a[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; mid; i++) add(a[i].val, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(a + l, tmp + l, (r - l) * <span class="keyword">sizeof</span>(oper));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt;= l; i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i].time &lt; mid) add(a[i].val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> ans[a[i].time] += sum(a[i].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; r; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].time &lt; mid) add(a[i].val, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        a[i].id = pos[x] = i;</span><br><span class="line">        a[i].val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        a[pos[x]].time = --time;</span><br><span class="line">        tmp[time] = a[pos[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i].time &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            a[i].time = --time;</span><br><span class="line">            tmp[time] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, tmp, n * <span class="keyword">sizeof</span>(oper));</span><br><span class="line">    cdq(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= n - m; i--) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

<h1 id="P4169-Violet-天使玩偶-SJY摆棋子"><a href="#P4169-Violet-天使玩偶-SJY摆棋子" class="headerlink" title="P4169 [Violet]天使玩偶/SJY摆棋子"></a>P4169 [Violet]天使玩偶/SJY摆棋子</h1><p>本题是坐标系上的题目，却不能使用坐标系转换解决，所以我们需要考虑使用数据结构。一种方法是使用 K-D Tree，但是 K-D Tree 的时间复杂度在本题中并不正确，而一般的数据结构又难以维护平面坐标，所以我们考虑使用可以解决多维偏序问题的 CDQ 分治。</p>
<p>我们需要把题目条件中的绝对值去掉才能方便地解决本题。考虑比较简单的情况：对于添加的点 $(x_i, y_i)$ 和查询的点 $(x_j, y_j)$，如果两点满足 $i &lt; j \And x_i \le x_j \And y_i \le y_j$，则我们可以用 $(x_j - x_i) + (y_j - y_i)$ 更新答案。注意到这是非常经典的三维偏序模型，因此可以使用 CDQ 分治套树状数组在 $O(n \log ^ 2 n)$ 内解决。$x_i$ 与 $x_j$ 的大小关系和 $y_i$ 与 $y_j$ 的大小关系一共可以构成四种情况。对于其它三种情况，我们只需要考虑将所有点沿 x 轴对称、沿 y 轴对称、同时沿 x 轴对称和沿 y 轴对称三种情况即可。</p>
<p>注意到本题对程序的常数要求很高，所以我们需要优化程序的常数：</p>
<ul>
<li>由于 CDQ 分治的性质，每次对一段区间内的点进行 CDQ 分治前要求所有点已经按照第一维排序，但是 CDQ 分治结束时所有点的已经不再按第一维排序。我们需要创建另一个数组保存所有操作，需要解决四种情况时分别从这个数组拷贝一份即可，而不是将所有点重新按照时间维排序。</li>
<li>对于开始时就有的 $n$ 个点，不应该直接把它们看作插入操作，然后对 $n + m$ 项操作进行 CDQ 分治，而是直接将他们按照横坐标排序，对所有插入和查询操作进行一次 CDQ 分治，然后再将开始时的 $n$ 个点和 $m$ 项操作用 CDQ 分治中的归并方法归并起来。</li>
<li>本题需要查询前缀最大值以及单点修改，这种情况可以不用线段树或者平衡树而用树状数组维护第三维。</li>
<li>尽可能多使用 <code>memset()</code> 和 <code>memcpy()</code> 函数。</li>
<li>对于四种情况，初始化所有点时需要将每个点都沿坐标轴翻转。一共有四次翻转，但是实际只需要三次循环就能实现。</li>
</ul>
<p>虽然优化后程序的效率会有一定提升，但在 $n, m \le 3 \times 10 ^ 5$ 的数据范围下，CDQ 分治仍需要使用 O2 优化才可以通过。</p>
<p>最后注意一下：某些询问的时间维的前面可能没有任何满足条件的插入点的操作，这时需要特判。</p>
<div><div class="fold_hider"><div class="close hider_title">代码：</div></div><div class="fold">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans[N], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> query &amp;tmp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; tmp.x || (x == tmp.x &amp;&amp; y &lt; tmp.y) || (x == tmp.x &amp;&amp; y == tmp.y &amp;&amp; op &lt; tmp.op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[N * <span class="number">2</span>], tmp[N * <span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_index_tree</span> &#123;</span> <span class="comment">// optimize</span></span><br><span class="line">    <span class="keyword">int</span> a[maxn + <span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= maxn) &#123;</span><br><span class="line">            a[x] = <span class="built_in">std</span>::max(a[x], v);</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, a[x]);</span><br><span class="line">            x ^= lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= maxn &amp;&amp; a[x]) &#123; <span class="comment">// optimize</span></span><br><span class="line">            a[x] = <span class="number">0</span>;</span><br><span class="line">            x += lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> query tmp[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = l, k = mid; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == r || (j &lt; mid &amp;&amp; q[j] &lt; q[k])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[j].op == <span class="number">1</span>) bit.add(q[j].y, q[j].x + q[j].y);</span><br><span class="line">            tmp[i] = q[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[k].op == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = bit.query(q[k].y); <span class="comment">// optimize</span></span><br><span class="line">                <span class="keyword">if</span> (t) ans[q[k].id] = <span class="built_in">std</span>::min(ans[q[k].id], q[k].x + q[k].y - t);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[i] = q[k++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; mid; i++)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) bit.clear(q[i].y);</span><br><span class="line">    <span class="built_in">memcpy</span>(q + l, tmp + l, (r - l) * <span class="keyword">sizeof</span>(query));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    solve(l, mid);</span><br><span class="line">    solve(mid, r);</span><br><span class="line">    merge(l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(q, q + n);</span><br><span class="line">    solve(n, n + m);</span><br><span class="line">    merge(<span class="number">0</span>, n, n + m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        q[i].op = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        q[i].x++, q[i].y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; n + m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;q[i].op, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">2</span>) q[i].id = cnt++;</span><br><span class="line">        q[i].x++, q[i].y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(tmp, q, <span class="keyword">sizeof</span>(q));</span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) tmp[i].x = maxn - tmp[i].x; <span class="comment">// optimize</span></span><br><span class="line">    <span class="built_in">memcpy</span>(q, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) tmp[i].y = maxn - tmp[i].y;</span><br><span class="line">    <span class="built_in">memcpy</span>(q, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m; i++) tmp[i].x = maxn - tmp[i].x;</span><br><span class="line">    <span class="built_in">memcpy</span>(q, tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></div>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/" rel="tag"># 离线算法</a>
              <a href="/tags/CDQ%E5%88%86%E6%B2%BB/" rel="tag"># CDQ分治</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/OI%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8A%E5%90%88%E5%B9%B6%E7%AC%94%E8%AE%B0/" rel="prev" title="树上合并笔记">
                  <i class="fa fa-chevron-left"></i> 树上合并笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/OI%E7%AC%94%E8%AE%B0/%E7%82%B9%E5%88%86%E6%B2%BB%E7%AC%94%E8%AE%B0/" rel="next" title="点分治笔记">
                  点分治笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  















  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
<script>
  $(document).ready(function () {
    $(document).on('click', '.fold_hider', function () {
      $('>.fold', this.parentNode).slideToggle();
      $('>:first', this).toggleClass('open');
    });
    //默认情况下折叠
    $("div.fold").css("display", "none");
  });
</script>
</html>
